import fs from "node:fs/promises";
import path from "node:path";
import chromium from "@sparticuz/chromium";
import puppeteer, { type Browser } from "puppeteer-core";

import { getFontsCssBase64 } from "./fonts";

let browserInstance: Browser | null = null;
let browserInitPromise: Promise<Browser> | null = null;

function getLocalPuppeteerExecutablePath(): string | undefined {
  const fromEnv =
    process.env.PUPPETEER_EXECUTABLE_PATH ||
    process.env.CHROME_PATH ||
    process.env.GOOGLE_CHROME_BIN ||
    process.env.CHROMIUM_PATH;

  if (fromEnv && fromEnv.trim()) return fromEnv.trim();

  const candidates = [
    // macOS
    "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome",
    "/Applications/Google Chrome Canary.app/Contents/MacOS/Google Chrome Canary",
    "/Applications/Chromium.app/Contents/MacOS/Chromium",
    "/Applications/Microsoft Edge.app/Contents/MacOS/Microsoft Edge",
    "/Applications/Brave Browser.app/Contents/MacOS/Brave Browser",
    // Linux
    "/usr/bin/google-chrome",
    "/usr/bin/google-chrome-stable",
    "/usr/bin/chromium",
    "/usr/bin/chromium-browser",
  ];

  return candidates.find((p) => {
    try {
      // Keep sync fs out; Chromium path existence is a quick check but optional.
      // We'll attempt launch and surface a clear error if missing.
      return Boolean(p);
    } catch {
      return false;
    }
  });
}

async function getBrowser(): Promise<Browser> {
  if (browserInstance && browserInstance.connected) return browserInstance;
  if (browserInitPromise) return browserInitPromise;

  browserInitPromise = (async () => {
    const isServerless = Boolean(process.env.VERCEL) || Boolean(process.env.AWS_LAMBDA_FUNCTION_NAME);
    const disableDevShmUsage = process.env.PUPPETEER_DISABLE_DEV_SHM_USAGE !== "0";

    const executablePath = isServerless
      ? await chromium.executablePath()
      : getLocalPuppeteerExecutablePath();

    if (!executablePath) {
      throw new Error(
        "Puppeteer не знайшов браузер. Встанови Chrome/Chromium або задай PUPPETEER_EXECUTABLE_PATH (або CHROME_PATH)."
      );
    }

    const commonArgs = [
      "--no-sandbox",
      "--disable-setuid-sandbox",
      "--single-process",
      "--no-zygote",
      "--no-first-run",
      "--disable-gpu",
      "--disable-features=site-per-process",
      "--font-render-hinting=none",
    ];

    const args = isServerless
      ? [...chromium.args, ...commonArgs]
      : [
          ...commonArgs,
          ...(disableDevShmUsage ? ["--disable-dev-shm-usage"] : []),
        ];

    browserInstance = await puppeteer.launch({
      executablePath,
      headless: true,
      args,
    });

    return browserInstance;
  })();

  try {
    return await browserInitPromise;
  } finally {
    browserInitPromise = null;
  }
}

export async function assertWkhtmltopdfAvailable(): Promise<void> {
  // Backwards-compatible name: callers still invoke this before PDF generation.
  // We now validate that Puppeteer can launch a browser.
  await getBrowser();
}

export async function loadBaseTemplate(): Promise<string> {
  const basePath = path.join(process.cwd(), "src/server/pdf/templates/base.html");
  const stylesPath = path.join(process.cwd(), "src/server/pdf/templates/styles.css");

  const [baseHtml, stylesCss] = await Promise.all([
    fs.readFile(basePath, "utf-8"),
    fs.readFile(stylesPath, "utf-8"),
  ]);

  const fontsCss = await getFontsCssBase64();

  return baseHtml
    .replace("{{FONTS}}", fontsCss)
    .replace("{{STYLES}}", stylesCss);
}

export type WkhtmltopdfOptions = {
  pageSize?: "Letter" | "A4";
  marginTop?: string;
  marginRight?: string;
  marginBottom?: string;
  marginLeft?: string;
  timeoutMs?: number;
};

export async function generatePdfFromHtml(htmlContent: string, options: WkhtmltopdfOptions = {}): Promise<Buffer> {
  // Keep the same API, but render via Puppeteer.
  await assertWkhtmltopdfAvailable();

  const pageSize = options.pageSize ?? "Letter";
  const marginTop = options.marginTop ?? "20mm";
  const marginRight = options.marginRight ?? "15mm";
  const marginBottom = options.marginBottom ?? "20mm";
  const marginLeft = options.marginLeft ?? "15mm";
  const timeoutMs = options.timeoutMs ?? 30_000;

  const browser = await getBrowser();
  const page = await browser.newPage();

  try {
    await page.setJavaScriptEnabled(false);

    // Block all external network requests (fonts/images/etc). We embed what we need.
    await page.setRequestInterception(true);
    page.on("request", (req) => {
      const url = req.url();
      const type = req.resourceType();

      // No outbound network.
      if (url.startsWith("http://") || url.startsWith("https://")) {
        void req.abort();
        return;
      }

      // Keep it minimal; HTML should be self-contained.
      if (type === "image" || type === "media" || type === "font") {
        void req.abort();
        return;
      }

      void req.continue();
    });

    await page.setContent(htmlContent, { waitUntil: "domcontentloaded", timeout: timeoutMs });

    const pdfBuffer = await page.pdf({
      printBackground: true,
      preferCSSPageSize: true,
      format: pageSize,
      margin: {
        top: marginTop,
        right: marginRight,
        bottom: marginBottom,
        left: marginLeft,
      },
      timeout: timeoutMs,
    });

    return Buffer.from(pdfBuffer);
  } finally {
    await page.close();
  }
}
